[
  {
    "objectID": "walkthrough.html",
    "href": "walkthrough.html",
    "title": "Hello, Quarto",
    "section": "",
    "text": "Markdown is an easy to read and write text format:\n\nIt’s plain text so works well with version control\nIt can be rendered into HTML, PDF, and more\nLearn more at: https://quarto.org/docs/authoring/"
  },
  {
    "objectID": "walkthrough.html#markdown",
    "href": "walkthrough.html#markdown",
    "title": "Hello, Quarto",
    "section": "",
    "text": "Markdown is an easy to read and write text format:\n\nIt’s plain text so works well with version control\nIt can be rendered into HTML, PDF, and more\nLearn more at: https://quarto.org/docs/authoring/"
  },
  {
    "objectID": "walkthrough.html#code-cell",
    "href": "walkthrough.html#code-cell",
    "title": "Hello, Quarto",
    "section": "Code Cell",
    "text": "Code Cell\nHere is a Python code cell:\n\nimport os\nos.cpu_count()\n\n8"
  },
  {
    "objectID": "walkthrough.html#equation",
    "href": "walkthrough.html#equation",
    "title": "Hello, Quarto",
    "section": "Equation",
    "text": "Equation\nUse LaTeX to write equations:\n\\[\n\\chi' = \\sum_{i=1}^n k_i s_i^2\n\\]\n\nimport plotly.express as px\nimport plotly.io as pio\ndf = px.data.iris()\nfig = px.scatter(df, x=\"sepal_width\", y=\"sepal_length\", \n                 color=\"species\", \n                 marginal_y=\"violin\", marginal_x=\"box\", \n                 trendline=\"ols\", template=\"simple_white\")\nfig.show()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Main page",
    "section": "",
    "text": "Hello there! I’m Alexander Wen, but just call me Alex. I am currently in the UBC MDS program, and you can expect this website about my work and tangibly related competitive programming antics to be updated in the upcoming months of the 2025 school year."
  },
  {
    "objectID": "index.html#competitive-programming-profiles",
    "href": "index.html#competitive-programming-profiles",
    "title": "Main page",
    "section": "Competitive Programming Profiles",
    "text": "Competitive Programming Profiles\nAs a start, here are a series of links to my main competitive programming profiles, ordered roughly in descending order of activity.\nCodeForces\nAtCoder\nLeetcode\nCodeChef"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html#featured-projects",
    "href": "index.html#featured-projects",
    "title": "Main page",
    "section": "Featured Projects",
    "text": "Featured Projects\ncdc_diabetes_prediction - Basic data analysis on predicting diabetes based on health and lifestyle features following sound data scientific workflows as part of the main project for DSCI 522 (Data Science Workflows), a course in the Master of Data Science program at the University of British Columbia."
  },
  {
    "objectID": "archive.html",
    "href": "archive.html",
    "title": "Archives",
    "section": "",
    "text": "This subpage is for storing the relatively old journal entries from when I logged my competitive programming contest practices more consistently until roughly August 2023. It is kept here mostly for archival purposes (links are currently broken), but I may look back through these logs later to upload them properly to this website.\nhttps://alxwen711.github.io/alxwen711_website_archive/",
    "crumbs": [
      "Archives"
    ]
  },
  {
    "objectID": "src/HonestCode/sparsetable.html",
    "href": "src/HonestCode/sparsetable.html",
    "title": "January 8th, 2026",
    "section": "",
    "text": "Sparse Tables\nSuppose a hiker is mapping out a mountain range. They walk across the mountain and record their current altitude in meters at important landmarks in this diagram:\n\n\n\nVarious mountain measurements.\n\n\nThese measurements can then be expressed in an array:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIndex #\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\nAltitude in meters\n800\n400\n700\n1000\n1300\n1600\n1200\n900\n\n\n\nFrom this array, the highest altitude in this entire mountain range is 1300 meters. But some travellers may only traverse part of this mountain range; for example, someone that travels from landmark 1 to 4 reaches a maximum altitude of 1000 meters, and another person who travels from landmark 7 to 8 reaches a maximum altitude of 1200 meters. These continuous segments are referred to as subarrays.\nNow imagine that many tourists ask about the highest altitude they can reach by traversing an arbitrary segment of this mountain range. Thus, a method to find the maximum value of any subarray in this measurement array is required, and each question must be answerable in a practically instant amount of time. An initial solution is to build a table with the maximum altitudes reached for every subarray from index \\(X\\) to \\(Y\\) like below:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nX = 1\nX = 2\nX = 3\nX = 4\nX = 5\nX = 6\nX = 7\nX = 8\n\n\n\n\nY = 1\n800\n-\n-\n-\n-\n-\n-\n-\n\n\nY = 2\n800\n400\n-\n-\n-\n-\n-\n-\n\n\nY = 3\n800\n700\n700\n-\n-\n-\n-\n-\n\n\nY = 4\n1000\n1000\n1000\n1000\n-\n-\n-\n-\n\n\nY = 5\n1300\n1300\n1300\n1300\n1300\n-\n-\n-\n\n\nY = 6\n1600\n1600\n1600\n1600\n1600\n1600\n-\n-\n\n\nY = 7\n1600\n1600\n1600\n1600\n1600\n1600\n1200\n-\n\n\nY = 8\n1600\n1600\n1600\n1600\n1600\n1600\n1200\n900\n\n\n\nAny tourist’s query can now be answered by instantly looking up the specific subarray in this table. This method is effective, but also tedious because for any positive value \\(C\\), increasing the length of this array by a factor of \\(C\\) will increase the number of subarrays computed by a factor of \\(C^2\\). In this example, all 36 possible subarrays are computed, which is manageable. But suppose on larger scale, a robot took far more measurements on the mountain, such as a million. This table method would then have to compute the maximum value of each of roughly 5 trillion subarrays, which is infeasible even with a computer.\nThere is a more efficient way because not every subarray maximum value has to be literally computed. For example, knowing that maximum values for the subarrays from index 1 to 4 and index 3 to 6 to be 1000 and 1600 respectively is enough to conclude that the maximum value for the subarray from index 1 to 6 must be 1600. This is because every index from 1 to 6 is in at least one of these subarrays, thus the maximum value for the entire subarray must be the higher of 1000 and 1600. This important observation motivates the following sparse table.\nLet \\(L\\) be the length of a subarray. Start by “computing” the maximum value of every single element subarray.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSubarray length\nX = 1\nX = 2\nX = 3\nX = 4\nX = 5\nX = 6\nX = 7\nX = 8\n\n\n\n\nL = 1\n800\n400\n700\n1000\n1300\n1600\n1200\n900\n\n\n\nThe maximum of the subarray of length \\(L\\) from index \\(X\\) to \\(X+L-1\\) inclusive is equal to the higher of the maximums for the subarray from index \\(X\\) to \\(X+L/2-1\\) and index \\(X+L/2\\) to \\(X+L-1\\). The computed subarray maximums for \\(L = 1\\) can then be used to compute the subarray maximums for \\(L = 2\\):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSubarray length\nX = 1\nX = 2\nX = 3\nX = 4\nX = 5\nX = 6\nX = 7\nX = 8\n\n\n\n\nL = 1\n800\n400\n700\n1000\n1300\n1600\n1200\n900\n\n\nL = 2\n800\n700\n1000\n1300\n1600\n1600\n1200\n-\n\n\n\nThis information can then be used to compute the subarray maximums for \\(L = 4\\):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSubarray length\nX = 1\nX = 2\nX = 3\nX = 4\nX = 5\nX = 6\nX = 7\nX = 8\n\n\n\n\nL = 1\n800\n400\n700\n1000\n1300\n1600\n1200\n900\n\n\nL = 2\n800\n700\n1000\n1300\n1600\n1600\n1200\n-\n\n\nL = 4\n1000\n1300\n1600\n1600\n1600\n-\n-\n-\n\n\n\nAnd lastly in this case, \\(L = 8\\) (further steps would use larger powers of 2 for \\(L\\)):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSubarray length\nX = 1\nX = 2\nX = 3\nX = 4\nX = 5\nX = 6\nX = 7\nX = 8\n\n\n\n\nL = 1\n800\n400\n700\n1000\n1300\n1600\n1200\n900\n\n\nL = 2\n800\n700\n1000\n1300\n1600\n1600\n1200\n-\n\n\nL = 4\n1000\n1300\n1600\n1600\n1600\n-\n-\n-\n\n\nL = 8\n1600\n-\n-\n-\n-\n-\n-\n-\n\n\n\nThe maximum of any subarray from index \\(A\\) to \\(B\\) can then be computed using this sparse table in 3 steps:\n\nCompute \\(N\\), the length of the subarray. (\\(N = B - A + 1\\))\nDetermine \\(M\\), the largest power of 2 (1, 2, 4, 8, 16, 32…) satisfying \\(M \\leq N\\).\nLook in the row \\(L = M\\) and choose the larger of the values in columns \\(X = A\\) and \\(X = B - M + 1\\), representing the subarrays from index \\(A\\) to \\(A + M - 1\\) and index \\(B - M + 1\\) to \\(B\\). These subarrays are guaranteed to cover every index from \\(A\\) to \\(B\\).\n\nAs an example, suppose a tourist wanted to know the highest altitude (maximum) between landmarks 2 to 4. Use the method to determine the maximum of the subarray from index 2 to 4:\n\n\\(N = 4 - 2 + 1\\) =&gt; \\(N = 3\\)\n\\(M = 2\\) (largest power of 2 less than or equal to 3)\nValue in \\(L = 2, X = 2\\) is 700; value in \\(L = 2, X = 4 - 2 + 1 = 3\\) is 1000. Thus the maximum altitude between landmarks 2 to 4 is 1000.\n\nWith the sparse table, only 21 total subarrays have their maximum computed, compared to 36 with the naive table approach. Where this efficiency is more pronounced is with more measurements; for any positive value \\(C\\), increasing the length of the array by a factor of \\(C\\) will now only increase the number of subarrays computed by a factor of \\(C\\text{log}(C)\\). Going back to the robot scenario, if the array consisted of a million value, the number of maximums for subarrays computed would decrease from roughly 5 trillion with a naive table to 19 million with a sparse table."
  },
  {
    "objectID": "index.html#honestcode-a-blog-about-competitive-programming",
    "href": "index.html#honestcode-a-blog-about-competitive-programming",
    "title": "Main page",
    "section": "HonestCode: A Blog About Competitive Programming",
    "text": "HonestCode: A Blog About Competitive Programming\nThis is something I’m planning on actually building up seriously. Pretty much a spot for me to occasionally talk about competitive programming topics, which includes:\n\nActual algorithm and data structure explanations\nContest recaps\nPractice methods\nA divulge of my thoughts on AI in the context of competitive programming that is only slightly less Um_nik-like\nInteresting problems\n\nFor now though here is a first post about Sparse Tables to get this started."
  }
]